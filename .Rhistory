library(dplyr)
cause_name <- c("Ischemic heart disease", "Alzheimer disease and other dementias", "Tracheal, bronchus, and lung cancer", "Cerebrovascular disease","Chronic obstructive pulmonary disease", "Lower respiratory infections",
"Chronic kidney disease", "Colon and rectum cancer", "Diabetes mellitus", "Breast cancer", "Self-harm",
"Pancreatic cancer", "Road injuries", "Other cardiovascular and circulatory diseases","Hypertensive heart disease")
num_deaths <- c(5.448323e+05, 2.388951e+05, 1.914620e+05, 1.771955e+05, 1.637929e+05,
9.599246e+04, 8.253946e+04, 7.929680e+04, 7.145021e+04, 4.932721e+04, 4.660644e+04,
4.625284e+04, 4.467170e+04, 4.223361e+04, 4.020373e+04)
?data.frame
deaths_df <- data.frame(cause_name, num_deaths)
View(deaths_df)
plot(deaths_df)
?plot()
plot(deaths_df, type = "p")
library(tidyverse)
deaths_df %>%
ggplot(aes(x = cause_name)) +
geom_point()
deaths_df %>%
ggplot(aes(x = cause_name, y = num_deaths)) +
geom_point()
deaths_df %>%
ggplot(aes(x = cause_name, y = num_deaths)) +
geom_point() +
theme(axis.text.x = element_text(angle = 30))
deaths_df %>%
ggplot(aes(x = cause_name, y = num_deaths)) +
geom_point() +
theme(axis.text.x = element_text(angle = 30)) +
scale_x_discrete(label = c("a", "b", "c", "d", "e", "f", "g", "h", "i", "j"))
deaths_df %>%
ggplot(aes(x = cause_name, y = num_deaths)) +
geom_point() +
scale_x_discrete(label = c("a", "b", "c", "d", "e", "f", "g", "h", "i", "j"))
deaths_df %>%
ggplot(aes(x = cause_name, y = num_deaths)) +
geom_point() +
scale_x_discrete(label = c("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o"))
deaths_df %>%
ggplot(aes(x = cause_name, y = num_deaths)) +
geom_point() +
scale_x_discrete(label = c("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o"))+
labs(title = "position encoding")
deaths_df %>%
ggplot(aes(x = cause_name, y = num_deaths)) +
geom_bar() +
scale_x_discrete(label = c("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o"))+
labs(title = "length encoding")
deaths_df %>%
ggplot(aes(x = cause_name)) +
geom_bar() +
scale_x_discrete(label = c("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o"))+
labs(title = "length encoding")
deaths_df %>%
ggplot(aes(x = cause_name, y = num_deaths)) +
geom_histogram() +
scale_x_discrete(label = c("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o"))+
labs(title = "length encoding")
deaths_df %>%
ggplot(aes(x = cause_name)) +
geom_histogram() +
scale_x_discrete(label = c("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o"))+
labs(title = "length encoding")
library(tidyverse)
library(knitr)
library(kableExtra)
library(httr)
library(jsonlite)
source("api-keys.R")
source("civic-info.R")
source("propublica.R")
remove(base_uri)
remove(endpoint)
remove(query_pa)
remove(query_params)
remove(response)
remove(parsed_data)
# Begin by making a request for all members of the house of representatives
# at the  /members endpoint. The ProPublica API is a bit particular in how
# it requires that you make requests. Rather than specify arguments, you'll
# need to construct a request string. For example, to request members you'll
# need to construct this URL:
#
# https://api.propublica.org/congress/v1/members/{chamber}/{state}/current.json
#
# Create a variable that stores the base URI (as a string) for the
# Pro Publica API
pp_base_uri <- "https://api.propublica.org/congress/v1"
# Request all members of the House of representatives at the /members endpoint.
pp_endpoint <- "/members"
# You'll replace {state} and  {chamber} with your values (the state
# abbreviation, and the word "house" -- removing the curly braces).
# You'll also need to specify your API key as a header using this syntax
# (a bit different than what's in the course book):
#
pp_response <- GET(pp_endpoint, {chamber}=="house", {state}==state_address, add_headers("X-API-Key" = pp_apikey))
# You'll replace {state} and  {chamber} with your values (the state
# abbreviation, and the word "house" -- removing the curly braces).
# You'll also need to specify your API key as a header using this syntax
# (a bit different than what's in the course book):
#
pp_response <- GET(pp_endpoint, {chamber}=="house", {state}=state_address, add_headers("X-API-Key" = pp_apikey))
# You'll replace {state} and  {chamber} with your values (the state
# abbreviation, and the word "house" -- removing the curly braces).
# You'll also need to specify your API key as a header using this syntax
# (a bit different than what's in the course book):
#
pp_response <- GET(pp_endpoint, {chamber}=="house", {state}=~state_address, add_headers("X-API-Key" = pp_apikey))
# You'll replace {state} and  {chamber} with your values (the state
# abbreviation, and the word "house" -- removing the curly braces).
# You'll also need to specify your API key as a header using this syntax
# (a bit different than what's in the course book):
#
pp_response <- GET(pp_endpoint, {chamber}=="house", {state}==~state_address, add_headers("X-API-Key" = pp_apikey))
# You'll replace {state} and  {chamber} with your values (the state
# abbreviation, and the word "house" -- removing the curly braces).
# You'll also need to specify your API key as a header using this syntax
# (a bit different than what's in the course book):
#
pp_response <- GET(pp_endpoint, {chamber}=="house", add_headers("X-API-Key" = pp_apikey))
View(linked_gci_reps)
# address of choice
address <- "14 East Cache La Poudre Street, Colorado Springs, CO"
#state-specific address of choice
state_address <- "CO"
gci_apikey <- "AIzaSyDvzlgHBMw3vyeDUQh7rPx2Rx9zoZDMV4o"
pp_apikey <- "HbK6EVBdhkQxrsEIgwOTT7TfvDd6xJD5s0IcvptZ"
# Load necessary packages
library(httr)
library(jsonlite)
library(dplyr)
# google civic info api key and address of choice
source("api-keys.R")
print(gci_apikey)
print(address)
# Create a variable that stores the base URI (as a string) for the
# Google Civic Info API (https://www.googleapis.com/civicinfo/v2)
gci_base_uri <- "https://www.googleapis.com/civicinfo/v2"
# Request the representatives for your address from the /representatives endpoint.
gci_endpoint <- "/representatives"
gci_query_params <- list(address = address, key = gci_apikey)
# Send the HTTP Request to download the data
# Extract the content and convert it from JSON
gci_response <- GET(paste0(gci_base_uri, gci_endpoint), query = gci_query_params)
print(gci_response)
gci_parsed_data <- fromJSON(content(gci_response, "text"))
# Data wrangling
offices <- gci_parsed_data$offices
officials <- gci_parsed_data$officials
# copied from canvas a6 description
num_to_rep <- unlist(lapply(gci_parsed_data$offices$officialIndices, length))
# expand `offices` df by number of elements in `officialIndices` column
expanded <- offices[rep(row.names(offices), num_to_rep),]
# mutate `index` column in `expanded` offices df and rename `position` column
expanded <- expanded %>%
mutate(index = row_number() -1) %>%
rename(position = name)
# mutate `index` column in `officials` df
officials <- officials %>% mutate(index = row_number() -1)
# Then, join officials and offices by `index` column to get full df
gci_joined_df <- full_join(officials, expanded, by = "index")
# Select relevant columns
gci_reps <- gci_joined_df %>%
select(name, urls, position, party, emails, phones, photoUrl)
# Total number of representatives
num_gci_reps <- nrow(gci_reps)
# Table of Representatives:
# Name hyperlinked
# Current Position
# Party Affiliation
# Email hyperlinked
# Phone number
# Photo (URL)
linked_gci_reps <- gci_reps
linked_gci_reps$name <- ifelse(linked_gci_reps$urls=="NULL", linked_gci_reps$name, paste0("[", linked_gci_reps$name, "](", linked_gci_reps$urls, ")"))
linked_gci_reps$emails <- ifelse(linked_gci_reps$emails=="NULL", "Not available", paste0("[", linked_gci_reps$emails, "](mailto:", linked_gci_reps$emails, ")"))
linked_gci_reps$photoUrl <- ifelse(is.na(linked_gci_reps$photoUrl), "Not available", paste0("<img src='", linked_gci_reps$photoUrl, "' style='height:100px'>"))
# Load necessary packages
library(httr)
library(jsonlite)
library(dplyr)
library(lubridate)
library(scales)
# google civic info api key and address of choice
source("api-keys.R")
pp_apikey
state_address
## House of Representatives Charts
# The second section you create should be on the House of Representatives.
# Using the ProPublica API(in your propublica.R script), you will get all
# members of the House of Representatives from the state corresponding to
# the address indicated. Note: for simplicity's sake, you can just create
# another variable with the two-letter abbreviation for the state that
# corresponds with your address.
#
# Begin by making a request for all members of the house of representatives
# at the  /members endpoint. The ProPublica API is a bit particular in how
# it requires that you make requests. Rather than specify arguments, you'll
# need to construct a request string. For example, to request members you'll
# need to construct this URL:
#
# https://api.propublica.org/congress/v1/members/{chamber}/{state}/current.json
#
# Create a variable that stores the base URI (as a string) for the
# Pro Publica API
pp_base_uri <- "https://api.propublica.org/congress/v1"
# Request all members of the House of representatives at the /members endpoint.
pp_endpoint <- "/members"
pp_response <- GET(paste0(pp_base_uri, pp_endpoint, "/house/", state_address, "/current.json"), add_headers("X-API-Key" = pp_apikey))
pp_parsed_data <- fromJSON(content(pp_response, "text"))
pp_reps <- flatten(pp_parsed_data$results)
## Two Charts
# Reps by Gender (male vs female)
plot_pp_reps_by_gender <- pp_reps %>%
ggplot(aes(x = gender)) +
geom_bar() +
labs(title = "Representatives by Gender", x = "Gender", y = "# of Representatives") +
scale_x_discrete(labels = c("F" = "Females", "M" = "Males")) +
coord_flip()
# Reps by Party (republican vs democratic)
plot_pp_reps_by_party <- pp_reps %>%
ggplot(aes(x = party)) +
geom_bar() +
labs(title = "Representatives by Party", x = "Party", y = "# of Representatives") +
scale_x_discrete(labels = c("D" = "Democrats", "R" = "Republicans")) +
coord_flip()
## Selected Representative Information
# Age
# Twitter (link)
# The percentage of time they agree with a vote (i.e., they vote yes on a vote
# that passes, or they vote no on a vote that fails)
# Note, the votes endpoint will only return the most recent 20 votes, which is
# fine.
# First of the members for given state-specific address
first_pp_reps <- pp_reps[1,]
# specific member
# https://api.propublica.org/congress/v1/members/{member}.json
member_pp_response <- GET(paste0(pp_base_uri, pp_endpoint, "/", first_pp_reps$id, ".json"), add_headers("X-API-Key" = pp_apikey))
member_pp_parsed_data <- fromJSON(content(member_pp_response, "text"))
member_pp_reps <- flatten(member_pp_parsed_data$results)
# specific member's vote positions (voting patterns)
# https://api.propublica.org/congress/v1/members/{member}/votes.json
member_vote_pp_response <- GET(paste0(pp_base_uri, pp_endpoint, "/", first_pp_reps$id, "/votes.json"), add_headers("X-API-Key" = pp_apikey))
member_vote_pp_parsed_data <- fromJSON(content(member_vote_pp_response, "text"))
member_vote_pp_reps <- flatten(member_vote_pp_parsed_data$results$votes[[1]])
# Name of specific member
name_first_pp_reps <- first_pp_reps$name
# Pronoun of specific member based on gender
pronoun <- if(first_pp_reps$gender == "F"){
print("her")
} else {
print("him")
}
# Age of specific member
age_member_pp_reps <- floor(interval(as.Date(member_pp_reps$date_of_birth), today()) / duration(num=1, unit = "years"))
# Twitter handle (hyperlinked)
twitter_member_pp_reps <- cell_spec(member_pp_reps$twitter_account, "html", link = (paste0("https://twitter.com/", member_pp_reps$twitter_account)))
# Percentage of member positions in accordance with voting results
percentage_accordance <- nrow(filter(member_vote_pp_reps,
(result %in% c("Passed", "Agreed to") & position == "Yes") |
(result == "Failed" & position == "No"))) / nrow(member_vote_pp_reps) * 100
# Load necessary packages
library(httr)
library(jsonlite)
library(tidyverse)
library(lubridate)
library(scales)
# Load necessary packages
library(httr)
library(jsonlite)
library(tidyverse)
library(lubridate)
library(scales)
# google civic info api key and address of choice
source("api-keys.R")
pp_apikey
state_address
## House of Representatives Charts
# The second section you create should be on the House of Representatives.
# Using the ProPublica API(in your propublica.R script), you will get all
# members of the House of Representatives from the state corresponding to
# the address indicated. Note: for simplicity's sake, you can just create
# another variable with the two-letter abbreviation for the state that
# corresponds with your address.
#
# Begin by making a request for all members of the house of representatives
# at the  /members endpoint. The ProPublica API is a bit particular in how
# it requires that you make requests. Rather than specify arguments, you'll
# need to construct a request string. For example, to request members you'll
# need to construct this URL:
#
# https://api.propublica.org/congress/v1/members/{chamber}/{state}/current.json
#
# Create a variable that stores the base URI (as a string) for the
# Pro Publica API
pp_base_uri <- "https://api.propublica.org/congress/v1"
# Request all members of the House of representatives at the /members endpoint.
pp_endpoint <- "/members"
pp_response <- GET(paste0(pp_base_uri, pp_endpoint, "/house/", state_address, "/current.json"), add_headers("X-API-Key" = pp_apikey))
pp_parsed_data <- fromJSON(content(pp_response, "text"))
pp_reps <- flatten(pp_parsed_data$results)
## Two Charts
# Reps by Gender (male vs female)
plot_pp_reps_by_gender <- pp_reps %>%
ggplot(aes(x = gender)) +
geom_bar() +
labs(title = "Representatives by Gender", x = "Gender", y = "# of Representatives") +
scale_x_discrete(labels = c("F" = "Females", "M" = "Males")) +
coord_flip()
# Reps by Party (republican vs democratic)
plot_pp_reps_by_party <- pp_reps %>%
ggplot(aes(x = party)) +
geom_bar() +
labs(title = "Representatives by Party", x = "Party", y = "# of Representatives") +
scale_x_discrete(labels = c("D" = "Democrats", "R" = "Republicans")) +
coord_flip()
## Selected Representative Information
# Age
# Twitter (link)
# The percentage of time they agree with a vote (i.e., they vote yes on a vote
# that passes, or they vote no on a vote that fails)
# Note, the votes endpoint will only return the most recent 20 votes, which is
# fine.
# First of the members for given state-specific address
first_pp_reps <- pp_reps[1,]
# specific member
# https://api.propublica.org/congress/v1/members/{member}.json
member_pp_response <- GET(paste0(pp_base_uri, pp_endpoint, "/", first_pp_reps$id, ".json"), add_headers("X-API-Key" = pp_apikey))
member_pp_parsed_data <- fromJSON(content(member_pp_response, "text"))
member_pp_reps <- flatten(member_pp_parsed_data$results)
# specific member's vote positions (voting patterns)
# https://api.propublica.org/congress/v1/members/{member}/votes.json
member_vote_pp_response <- GET(paste0(pp_base_uri, pp_endpoint, "/", first_pp_reps$id, "/votes.json"), add_headers("X-API-Key" = pp_apikey))
member_vote_pp_parsed_data <- fromJSON(content(member_vote_pp_response, "text"))
member_vote_pp_reps <- flatten(member_vote_pp_parsed_data$results$votes[[1]])
# Name of specific member
name_first_pp_reps <- first_pp_reps$name
# Pronoun of specific member based on gender
pronoun <- if(first_pp_reps$gender == "F"){
print("her")
} else {
print("him")
}
# Age of specific member
age_member_pp_reps <- floor(interval(as.Date(member_pp_reps$date_of_birth), today()) / duration(num=1, unit = "years"))
# Twitter handle (hyperlinked)
twitter_member_pp_reps <- cell_spec(member_pp_reps$twitter_account, "html", link = (paste0("https://twitter.com/", member_pp_reps$twitter_account)))
# Percentage of member positions in accordance with voting results
percentage_accordance <- nrow(filter(member_vote_pp_reps,
(result %in% c("Passed", "Agreed to") & position == "Yes") |
(result == "Failed" & position == "No"))) / nrow(member_vote_pp_reps) * 100
getwd()
getwd()
library(tidyverse)
library(plotly)
listings_exp <- read.csv("data/listings_exp.csv")
getwd()
setwd("~/Documents/INFO201/seattle-airbnbs-visualization")
listings_exp <- read.csv("data/listings_exp.csv")
amenities <- listings_exp %>%
separate_rows(amenities, sep = ",")
amenities$amenities <- gsub("[{\"}]", "", amenities$amenities)
test <- amenities %>%
group_by(id, price, review_scores_rating, neighbourhood_cleansed, neighbourhood_group_cleansed) %>%
summarize(count = n()) %>%
arrange(desc(count))
plot_ly(test, x = ~count, y = ~review_scores_rating, type = "scatter")
plot_ly(test, x = ~count, y = ~price, type = "scatter")
View(test)
test %>%
select(count, price) %>%
filter(!is.na)
test %>%
select(count, price) %>%
filter(!is.na())
test %>%
filter(!is.na(c("count", "price")))
test %>%
filter(count != NA, price != NA)
test %>%
arrange(desc(price))
test$price <- as.numeric(gsub("[$, ]", "", test$price))
plot_ly(test, x = ~count, y = ~price, type = "scatter")
test %>%
filter(price != is.na(price), count != is.na(count))
test %>%
filter(price != is.na(price), count != is.na(count))
test %>%
filter(price != is.na(price), count != is.na(count)) %>%
plot_ly(x = ~count, y = ~price, type = "scatter")
plot_ly(test, x = ~count, y = ~price, type = "scatter")
is.na(test$price)
is.na(test$count)
?plot()
typeof(test$count)
typeof(test$price   )
plot(test$count, test$price)
?plotly
test %>%
ggplot(aes(x = count, y = price)) %>%
geom_point()
test %>%
ggplot(aes(x = count, y = price)) +
geom_point()
test %>%
filter(price < 2000) %>%
ggplot(aes(x = count, y = price)) +
geom_point()
test %>%
filter(price < 1000) %>%
ggplot(aes(x = count, y = price)) +
geom_point()
mean(test$count)
test %>%
ggplot(aes(x = count, y = review_scores_rating)) +
geom_point()
test %>%
ggplot(aes(x = count, y = neighbourhood_group_cleansed)) +
geom_point()
test %>%
ggplot(aes(x = review_scores_rating, y = neighbourhood_group_cleansed)) +
geom_point()
test %>%
ggplot(aes(x = mean(review_scores_rating, na.rm = T), y = neighbourhood_group_cleansed)) +
geom_point()
test %>%
group_by(neighbourhood_group_cleansed) %>%
summarize(count = n(), avgscore = mean(review_scores_rating, na.rm = T)) %>%
ggplot(aes(x = neighbourhood_group_cleansed, y = avgscore, color = count)) +
geom_point()
View(test)
View(listings_exp)
colnames(listings_exp)
listings_exp$host_is_superhost
plot(x = listings_exp$review_scores_rating, y = listings_exp$host_is_superhost)
test %>%
mbnm
?merge()
merge(test, listings_exp) %>%
plot(x = count, y = host_is_superhost)
merge(test, listings_exp) %>%
plot(x = ~count, y = ~host_is_superhost)
test1 <- merge(test, listings_exp)
?left_join
test1 <- full_join(test, listings_exp)
test1 <- read.csv("data/listings_exp.csv") %>%
ddsfa
listings_exp$price <- as.numeric(gsub("[$, ]", "", listings_exp$price))
test1 <- full_join(test, listings_exp)
plot(x = ~count, y = ~host_is_superhost)
plot(data = test1, x = ~count, y = ~host_is_superhost)
plot(data = test1, x = count, y = host_is_superhost)
View(test1)
plot(data = test1, x = ~count, y = ~host_is_superhost)
test1 %>%
ggplot(aes(x = host_is_superhost, y = count)) +
geom_bar
test1 %>%
ggplot(aes(x = host_is_superhost, y = count)) +
geom_bar()
test1 %>%
ggplot(aes(x = host_is_superhost, y = count)) +
geom_histogram()
test1 %>%
ggplot(aes(x = host_is_superhost, y = count)) +
geom_point()
test1 %>%
ggplot(aes(x = host_is_superhost, y = review_ratings_score)) +
geom_point()
test1 %>%
ggplot(aes(x = host_is_superhost, y = review_scores_rating)) +
geom_point()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
